/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package igtools.gui2.positions;

import igtools.common.alignment.B3NSmithWaterman;
import igtools.common.nucleotide.B3Nucleotide;
import igtools.common.sequence.B3Sequence;
import igtools.dictionaries.elsa.IELSAIterator;
import igtools.gui2.WSSequence;
import java.awt.Color;
import java.awt.Graphics;
import java.util.Arrays;

/**
 *
 * @author vbonnici
 */
public class CoveragePanel extends javax.swing.JPanel {

    
    private WSSequence wsseq;
    private int[] positions;
    private int k;
    
    private final Color backgroundColor = Color.WHITE;
    //private final Color nRegionColor = Color.LIGHT_GRAY;
    //private final Color nRegionColor = new Color(250,250,250);
    private final Color nRegionColor = Color.LIGHT_GRAY;
    private final Color barColor = Color.BLUE;
    private final Color nBarColor = Color.CYAN;
    
    private final int margin = 10;
    
    /**
     * Creates new form PositionsPanel
     */
    public CoveragePanel(WSSequence wsseq, int[] positions, int k) {
        this.wsseq = wsseq;
        this.positions = positions;
        this.k = k;
        
        Arrays.sort(positions);
        
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    
    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        
        g.setColor(this.backgroundColor);
        g.fillRect(0, 0, this.getWidth(), this.getHeight());
        
        int width = this.getWidth();
        int height = this.getHeight();
        
        int areaWidth = width - (2*margin);
        int areaHeight = height - (2*margin);
        
        int[]  bins = new int[areaWidth];
        int[] ncovered = new int[bins.length];
        for(int i=0; i<bins.length; i++){
            bins[i] = 0;
            ncovered[i] = 0;
        }
        
        //1 bin for each pixel
        
        double wFactor = ((double)bins.length) / ((double)this.wsseq.getB3seq().length() + 1.0);
        //double invWFactor = (double)this.wsseq.getB3seq().length() / ((double)bins.length);
        System.out.println(bins.length +" "+ this.wsseq.getB3seq().length() +" "+ wFactor);
        System.out.println((int)((double)(this.wsseq.getB3seq().length()-1) * wFactor));
        
        
        /*for(int i=0; i<this.positions.length; i++){
            bins[  (int)((double)this.positions[i] * wFactor) ]++;
        }*/
        
        
        
        //TODO  better when an occurence is on two different bins
        
        int ibin = 0;
        int binSize = (int)((double)this.wsseq.getB3seq().length() / ((double)bins.length));
        int binLimit = binSize;
        
        //System.out.println("binSize "+binSize);
        
        for(int i=0; i<positions.length; i++){
            if(positions[i] >= (ibin+1)*binSize){
                while(positions[i] >= (ibin+1)*binSize){
                    ibin++;
                    binLimit += binSize;
                }
                //System.out.println("pos "+positions[i]+"; ibin "+ibin+"; binLimit "+binLimit);
            }
            
            if(i==0 || bins[ibin] == 0){
                if(positions[i] + this.k >= binLimit ){
                    bins[ibin] += binLimit - positions[i];
                    if(ibin < bins.length-1)
                        bins[ibin+1] = positions[i] + this.k - binLimit;
                }
                else{
                    bins[ibin] += this.k;
                }
            }
            else{
                if(positions[i] - positions[i-1] < this.k){
                    bins[ibin] += positions[i] - positions[i-1];
                }
                else{
                    bins[ibin] += this.k;
                }
            }
        }
        
        
        
        B3Sequence b3seq = wsseq.getB3seq();
        
        for(int i=0; i<b3seq.length(); i++){
            if(b3seq.getB3(i) == B3Nucleotide.N_CODE)
                ncovered[ (int)(((double)i) * wFactor) ]++;
        }
        
        
        
        int maxValue = Integer.MIN_VALUE;
        for(int i=0; i<bins.length; i++){
            if(bins[i] > maxValue)
                maxValue = bins[i];
        }
        
        int maxNValue = Integer.MIN_VALUE;
        for(int i=0; i<ncovered.length; i++){
            //if(ncovered[i] > maxValue)
            if(ncovered[i] > maxNValue)
                maxNValue = ncovered[i];
        }
        
        
        double hFactor = ((double)maxValue) / ((double)areaHeight);
        double nHFactor = ((double)maxNValue) / ((double)areaHeight);
        
        for(int i=0; i<bins.length; i++){
            
            int hh = (int)((double)ncovered[i] / nHFactor);
            g.setColor(nRegionColor);
            g.fillRect(margin + i, margin + (areaHeight - hh), 1, hh);
            
            hh = (int)((double)bins[i] / hFactor);
            g.setColor(this.barColor);
            g.fillRect(margin + i, margin + (areaHeight - hh), 1, hh);
        }
        
    }

}
