/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package igtools.gui2.positions;

import igtools.common.alignment.B3NSmithWaterman;
import igtools.common.nucleotide.B3Nucleotide;
import igtools.common.sequence.B3Sequence;
import igtools.dictionaries.elsa.IELSAIterator;
import igtools.gui2.WSSequence;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.util.Arrays;
import javax.swing.JComponent;

/**
 *
 * @author vbonnici
 */
public class NCoverageGraphPanel extends javax.swing.JPanel {

    
    private WSSequence wsseq;
    
    private final Color backgroundColor = Color.WHITE;
    //private final Color nRegionColor = Color.LIGHT_GRAY;
    //private final Color nRegionColor = new Color(250,250,250);
    private final Color nRegionColor = Color.GRAY;
    
    private int margin = 10;
    private int pWidth = 0;
    private int pHeight = 0;
    private JComponent parentComp = null;
    
    /**
     * Creates new form PositionsPanel
     */
    public NCoverageGraphPanel(WSSequence wsseq) {
        this.wsseq = wsseq;
        
        initComponents();
    }
    
    
    public void setStyleProperties(int margin, int width, int height, JComponent parent){
        this.margin = margin;
        this.pWidth = width;
        this.pHeight = height;
        this.parentComp = parent;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    
    @Override
    public Dimension getPreferredSize() {
        if(parentComp != null){
            int w = pWidth > 0 ? pWidth : parentComp.getWidth();
            int h = pHeight > 0 ? pHeight : parentComp.getHeight();
            return new Dimension(w,h);
        }
        return new Dimension(50,  300);
    }
    
    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        
        g.setColor(this.backgroundColor);
        g.fillRect(0, 0, this.getWidth(), this.getHeight());
        
        int width = this.getWidth();
        int height = this.getHeight();
        
        System.out.println(width+" "+height);
        
        int areaWidth = width - (2*margin);
        int areaHeight = height - (2*margin);
        
        int[] ncovered = new int[areaWidth];
        for(int i=0; i<ncovered.length; i++){
            ncovered[i] = 0;
        }
        
        //1 bin for each pixel
   
        
        
        
        //TODO  better when an occurence is on two different bins
        
        int ibin = 0;
        int binSize = (int)Math.ceil((double)this.wsseq.getB3seq().length() / ((double)ncovered.length));
        int binLimit = binSize;
        
        
        B3Sequence b3seq = wsseq.getB3seq();
        
        for(int i=0; i<b3seq.length(); i++){
            if(i == binLimit){
                ibin++;
                binLimit += binSize;
            }
            if(b3seq.getB3(i) == B3Nucleotide.N_CODE){
                try{
                ncovered[ ibin ]++;
                }catch(Exception e){
                    System.out.println(ncovered.length+" "+ ibin +" "+ binSize + " "+ i + " "+binLimit);
                }
            }
        }
        
        int maxNValue = Integer.MIN_VALUE;
        for(int i=0; i<ncovered.length; i++){
            if(ncovered[i] > maxNValue)
                maxNValue = ncovered[i];
        }
        
        
        double nHFactor = ((double)maxNValue) / ((double)areaHeight);
        
        g.setColor(nRegionColor);
        
        for(int i=0; i<ncovered.length; i++){
            int hh = (int)((double)ncovered[i] / nHFactor);
            
            g.fillRect(margin + i, margin + (areaHeight - hh), 1, hh);
        }
        
    }

}
